<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Documentation &mdash; mode-count 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="mode-count 0.1 documentation" href="index.html" />
    <link rel="next" title="API" href="api.html" />
    <link rel="prev" title="&lt;no title&gt;" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="documentation">
<h1>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h1>
<p>This software package implements methods from the paper &#8220;Control synthesis for large collections of systems with mode-counting constraints&#8221;, which synthesize a control strategy for aggregate dynamics such that mode-counting constraints are satisfied.</p>
<p>Currently, only mode-counting constraints pertaining to a single mode can be enforced, while the paper above develops the theory for arbitrarily many modes.</p>
<div class="section" id="dependencies">
<h2>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Python with working <a class="reference external" href="http://www.numpy.org">numpy</a>, <a class="reference external" href="http://www.scipy.org">scipy</a>, and <a class="reference external" href="https://networkx.github.io">networkx</a></li>
<li><a class="reference external" href="http://matplotlib.org">matplotlib</a> (for plotting)</li>
<li><a class="reference external" href="http://www.gurobi.com">Gurobi</a>  (recommended) or <a class="reference external" href="https://www.mosek.com/products/mosek">Mosek</a> and their Python interfaces.</li>
</ul>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>Currently, no automatic installation is provided. Execute files from the downloaded directory.</p>
</div>
<div class="section" id="synthesis">
<h2>Synthesis<a class="headerlink" href="#synthesis" title="Permalink to this headline">¶</a></h2>
<p>The synthesis procedure consists of two steps. First, an abstraction of the continuous dynamics is created. Secondly, a linear program is formed using the abstraction from whose solution an strategy can be extracted.</p>
<div class="section" id="construct-an-abstraction">
<h3>Construct an abstraction<a class="headerlink" href="#construct-an-abstraction" title="Permalink to this headline">¶</a></h3>
<p>There is a class <a class="reference internal" href="api.html#modecount.Abstraction" title="modecount.Abstraction"><code class="xref py py-class docutils literal"><span class="pre">Abstraction</span></code></a> for handling abstractions.
Dynamical modes are added to the abstraction using the function :py:func:add_mode`,
which takes as argument a function representing a vector field:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c1"># Create an abstraction of the 2D domain [-1,1]^2,</span>
<span class="c1"># with space and time discretization 0.1</span>
<span class="n">ab</span> <span class="o">=</span> <span class="n">Abstraction</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Add a mode given by the vector field</span>
<span class="c1"># \dot x_0 = -x_1</span>
<span class="c1"># \dot x_1 =  x_0</span>
<span class="n">ab</span><span class="o">.</span><span class="n">add_mode</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span>

<span class="n">ab</span><span class="o">.</span><span class="n">plot_planar</span><span class="p">()</span> <span class="c1"># plot it</span>
</pre></div>
</div>
<dl class="class">
<dt>
<em class="property">class </em><code class="descclassname">modecount.</code><code class="descname">Abstraction</code><span class="sig-paren">(</span><em>lower_bounds</em>, <em>upper_bounds</em>, <em>eta</em>, <em>tau</em><span class="sig-paren">)</span></dt>
<dd><p>Discrete abstraction of the hyper box defined by <em>lower_bounds</em> and <em>upper_bounds</em>.
Time discretization is <em>tau</em> and space discretization is given by <em>eta</em>.
Mode transitions are added with <a class="reference internal" href="api.html#modecount.Abstraction.add_mode" title="modecount.Abstraction.add_mode"><code class="xref py py-func docutils literal"><span class="pre">add_mode()</span></code></a>.</p>
</dd></dl>

<p>In order to verify that a given abstraction is an approximate bisimulation of a given vector field <span class="math">\(\dot x = f(x)\)</span>, a <span class="math">\(\mathcal{KL}\)</span>-function <span class="math">\(\beta(\cdot, \cdot)\)</span> corresponding to <span class="math">\(f\)</span> is required.</p>
<dl class="function">
<dt id="modecount.verify_bisim">
<code class="descclassname">modecount.</code><code class="descname">verify_bisim</code><span class="sig-paren">(</span><em>beta</em>, <em>tau</em>, <em>eta</em>, <em>eps</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.verify_bisim" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a <span class="math">\(\mathcal{KL}\)</span>-function <em>beta</em> for a continuous system, return <code class="docutils literal"><span class="pre">True</span></code> if the abstraction
created with time discretization <em>tau</em> and space discretization <em>eta</em> passes the <em>eps</em>-approximate bisimilarity
test, and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<p>The <a class="reference internal" href="api.html#modecount.Abstraction" title="modecount.Abstraction"><code class="xref py py-class docutils literal"><span class="pre">Abstraction</span></code></a> has a member <em>graph</em> which is a <a class="reference external" href="https://networkx.github.io">networkx</a> <code class="docutils literal"><span class="pre">DiGraph</span></code>,
where edges are labeled according to dynamical mode.</p>
</div>
<div class="section" id="synthesize-a-mode-counting-strategy">
<h3>Synthesize a mode-counting strategy<a class="headerlink" href="#synthesize-a-mode-counting-strategy" title="Permalink to this headline">¶</a></h3>
<p>Given a <a class="reference external" href="https://networkx.github.io">networkx</a> <code class="docutils literal"><span class="pre">DiGraph</span></code>, where edges are labeled with integers numbered from
1 to <span class="math">\(M\)</span>, a mode-counting strategy can be synthesized using <a class="reference internal" href="#modecount.prefix_suffix_feasible" title="modecount.prefix_suffix_feasible"><code class="xref py py-func docutils literal"><span class="pre">prefix_suffix_feasible()</span></code></a>. A number of
options are possible, including whether the system should be solved as a linear program (LP), or an integer
linear program (ILP).</p>
<dl class="function">
<dt id="modecount.prefix_suffix_feasible">
<code class="descclassname">modecount.</code><code class="descname">prefix_suffix_feasible</code><span class="sig-paren">(</span><em>problem_data</em>, <em>verbosity=1</em>, <em>solver=None</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.prefix_suffix_feasible" title="Permalink to this definition">¶</a></dt>
<dd><p>Define and solve a mode-counting synthesis problem
with a prefix-suffix strategy.</p>
<p>Inputs:</p>
<ul>
<li><p class="first"><em>problem_data</em>: dictionary with the following fields:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'graph'</span></code>                     : mode-transition graph G</li>
<li><code class="docutils literal"><span class="pre">'init'</span></code>                      : initial configuration in G</li>
<li><code class="docutils literal"><span class="pre">'horizon'</span></code>       : length of strategy prefix part</li>
<li><code class="docutils literal"><span class="pre">'cycle_set'</span></code>     : set of cycles from which suffix part is formed</li>
<li><code class="docutils literal"><span class="pre">'mode'</span></code>          : mode to count</li>
<li><code class="docutils literal"><span class="pre">'lb_suffix'</span></code>     : lower mode-counting bound in suffix phase</li>
<li><code class="docutils literal"><span class="pre">'ub_suffix'</span></code>     : upper mode-counting bound in suffix phase</li>
</ul>
<p>Optional fields</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'lb_prefix'</span></code>       : lower mode-counting bound in prefix phase (default: lb_suffix)</li>
<li><code class="docutils literal"><span class="pre">'ub_prefix'</span></code>       : upper mode-counting bound in prefix phase (default: ub_suffix)</li>
<li><code class="docutils literal"><span class="pre">'order_function'</span></code>  : a function that is a bijection that maps nodes in G to integers <span class="math">\([0, 1, \ldots , N]\)</span>  (default: G.nodes().index)</li>
<li><code class="docutils literal"><span class="pre">'forbidden_nodes'</span></code> : nodes in G that can not be visited (default: [])</li>
<li><code class="docutils literal"><span class="pre">'ilp'</span></code>             : if true, solve as ILP (default: <code class="docutils literal"><span class="pre">True</span></code>)</li>
</ul>
</li>
<li><p class="first"><em>verbosity</em>: level of verbosity</p>
</li>
</ul>
<p>Output: a dictionary with the following fields:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'controls'</span></code>        : prefix part u of strategy, u[:,t] is control at time t</li>
<li><code class="docutils literal"><span class="pre">'states'</span></code>          : states x generated by u, x[:,t] is state at time t</li>
<li><code class="docutils literal"><span class="pre">'cycles'</span></code>          : suffix cycles</li>
<li><code class="docutils literal"><span class="pre">'assignments'</span></code>     : suffix assignments</li>
</ul>
<p>Example: see example_simple.py</p>
</dd></dl>

<div class="highlight-python"><div class="highlight"><pre><span class="c1"># G a graph, `init` required initial condition</span>

<span class="n">prob_data</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;graph&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span>                                             <span class="c1"># graph</span>
<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;order_function&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>  <span class="c1"># function mapping node -&gt; integer (improves speed if defined)</span>

<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;init&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init</span>                                           <span class="c1"># initial state configuration</span>
<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;forbidden_nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes_with_selfloops</span><span class="p">()</span>         <span class="c1"># unsafe set</span>

<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>                                           <span class="c1"># mode to control</span>
<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;lb_suffix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">33</span>                             <span class="c1"># lower mode-count bound for mode 1</span>
<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;ub_suffix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">33</span>                             <span class="c1"># upper mode-count bound for mode 1</span>

<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;ilp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>                                         <span class="c1"># solve as ILP</span>

<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;horizon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>                                       <span class="c1"># prefix horizon</span>

<span class="n">prob_data</span><span class="p">[</span><span class="s1">&#39;cycle_set&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">simple_cycles</span><span class="p">(</span><span class="n">ab</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>  <span class="c1"># use all simple cycles</span>

<span class="c1"># Solve discrete mode synthesis problem</span>
<span class="n">prob_sol</span> <span class="o">=</span> <span class="n">prefix_suffix_feasible</span><span class="p">(</span><span class="n">prob_data</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="order-function">
<h4>Order function<a class="headerlink" href="#order-function" title="Permalink to this headline">¶</a></h4>
<p>For computational efficiency, it is beneficial if the index of a nodes in the graph can be indexed at a low computational cost. To this end, an <em>order function</em> can be provided as input to many of the functions. An order function to a graph <strong>G</strong> is a function that assigns a unique integer to each node in <strong>G</strong>. For graphs obtained from abstractions as above, an efficient order function is provided in the <a class="reference internal" href="api.html#modecount.Abstraction" title="modecount.Abstraction"><code class="xref py py-class docutils literal"><span class="pre">Abstraction</span></code></a> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c1"># ab is an abstraction</span>
<span class="n">order_fcn</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">node_to_idx</span>  <span class="c1"># efficient order function for ab.graph</span>
</pre></div>
</div>
<p>The default behavior is to use <code class="docutils literal"><span class="pre">G.nodes().index</span></code>, which must iterate through all nodes of <strong>G</strong> to find the index of a node.</p>
</div>
</div>
<div class="section" id="two-step-approach">
<h3>Two-step approach<a class="headerlink" href="#two-step-approach" title="Permalink to this headline">¶</a></h3>
<p>To alleviate the computational burden required by solving an ILP, the following two-step approach can be used</p>
<ol class="arabic simple">
<li>Find a non-integer strategy</li>
<li>Round the suffix part to integers</li>
<li>Find a prefix to the suffix</li>
</ol>
<p>The suffix part of a non-integer strategy resulting from an LP can be rouded using <a class="reference internal" href="api.html#modecount.make_integer" title="modecount.make_integer"><code class="xref py py-func docutils literal"><span class="pre">make_integer()</span></code></a>. Then, <a class="reference internal" href="#modecount.prefix_feasible" title="modecount.prefix_feasible"><code class="xref py py-func docutils literal"><span class="pre">prefix_feasible()</span></code></a> can be called to solve a (significantly smaller) ILP in order to find a
prefix strategy.:</p>
<div class="highlight-python"><div class="highlight"><pre># Set up and solve LP
nonint_data = { ..., ilp = False, ... }
nonint_solution = prefix_suffix_feasible(nonint_data)

# Set up and solve ILP
int_data = nonint_data.copy()
int_data[&#39;ilp&#39;] = True
int_data[&#39;cycle_set&#39;] = nonint_solution[&#39;cycles&#39;]
# round the suffix part of LP solution
int_data[&#39;assignments&#39;] = make_integer(nonint_solution[&#39;assignments&#39;])

# Find a prefix
int_solution = prefix_feasible(nonint_data)
</pre></div>
</div>
<dl class="function">
<dt id="modecount.prefix_feasible">
<code class="descclassname">modecount.</code><code class="descname">prefix_feasible</code><span class="sig-paren">(</span><em>problem_data</em>, <em>verbosity=1</em>, <em>solver=None</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.prefix_feasible" title="Permalink to this definition">¶</a></dt>
<dd><p>Define and solve the prefix part of a mode-counting 
synthesis problem (requires a given suffix part)</p>
<p>Inputs:</p>
<ul>
<li><p class="first"><em>problem_data</em>: dictionary with the following fields:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'graph'</span></code>                     : mode-transition graph G</li>
<li><code class="docutils literal"><span class="pre">'init'</span></code>                      : initial configuration in G</li>
<li><code class="docutils literal"><span class="pre">'horizon'</span></code>           : length of strategy prefix part</li>
<li><code class="docutils literal"><span class="pre">'cycle_set'</span></code>     : cycles to form suffix part</li>
<li><code class="docutils literal"><span class="pre">'assignments'</span></code>   : assignments to <code class="docutils literal"><span class="pre">'cycle_set'</span></code></li>
<li><code class="docutils literal"><span class="pre">'mode'</span></code>          : mode to count</li>
<li><code class="docutils literal"><span class="pre">'lb_prefix'</span></code>     : lower mode-counting bound in prefix phase</li>
<li><code class="docutils literal"><span class="pre">'ub_prefix'</span></code>     : upper mode-counting bound in prefix phase</li>
</ul>
<p>Optional fields</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'order_function'</span></code> : a function that is a bijection that maps nodes in G to integers <span class="math">\([0, 1, \ldots , N]\)</span>  (default: G.nodes().index)</li>
<li><code class="docutils literal"><span class="pre">'forbidden_nodes'</span></code>: nodes in G that can not be visited (default: [])</li>
<li><code class="docutils literal"><span class="pre">'ilp'</span></code>            : if true, solve as ILP (default: <code class="docutils literal"><span class="pre">True</span></code>)</li>
</ul>
</li>
<li><p class="first"><em>verbosity</em>: level of verbosity</p>
</li>
</ul>
<p>Output: a dictionary with the following fields:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'controls'</span></code>       : prefix part u of strategy, u[:,t] is control at time t</li>
<li><code class="docutils literal"><span class="pre">'states'</span></code>         : states x generated by u, x[:,t] is state at time t</li>
<li><code class="docutils literal"><span class="pre">'cycles'</span></code>         : suffix cycles (same as input)</li>
<li><code class="docutils literal"><span class="pre">'assignments'</span></code>    : suffix assignments (same as input)</li>
</ul>
</dd></dl>

</div>
</div>
<div class="section" id="simulate-strategy">
<h2>Simulate strategy<a class="headerlink" href="#simulate-strategy" title="Permalink to this headline">¶</a></h2>
<p>A strategy synthesized as above can be simulated with an instance of <a class="reference internal" href="api.html#modecount.CycleControl" title="modecount.CycleControl"><code class="xref py py-class docutils literal"><span class="pre">CycleControl</span></code></a>, which provides for a linear system <span class="math">\(\mathbf{w}(t+1) + A \mathbf{w} + B \mathbf{r}\)</span>. Such matrices <span class="math">\(A,B\)</span> can be computed by <a class="reference internal" href="api.html#modecount.lin_syst" title="modecount.lin_syst"><code class="xref py py-func docutils literal"><span class="pre">lin_syst()</span></code></a> (note that the same order function must be used throughout).:</p>
<div class="highlight-python"><div class="highlight"><pre># assume an abstraction ab has been created
problem_data = { ..., &#39;graph&#39; = ab.graph, &#39;order_function&#39; = ab.node_to_idx, ... }
int_solution = prefix_suffix_feasible(problem_data)
A,B = lin_syst(ab.graph, order_fcn = ab.node_to_idx)

controls = CycleControl(ab.graph, int_solution, ab.node_to_idx)

# controls can now be extracted with controls.get_u(t, state)
</pre></div>
</div>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Working examples can be found in the <code class="docutils literal"><span class="pre">examples/</span></code> and <code class="docutils literal"><span class="pre">examples_paper/</span></code> directories.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Documentation</a><ul>
<li><a class="reference internal" href="#dependencies">Dependencies</a></li>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#synthesis">Synthesis</a><ul>
<li><a class="reference internal" href="#construct-an-abstraction">Construct an abstraction</a></li>
<li><a class="reference internal" href="#synthesize-a-mode-counting-strategy">Synthesize a mode-counting strategy</a><ul>
<li><a class="reference internal" href="#order-function">Order function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#two-step-approach">Two-step approach</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simulate-strategy">Simulate strategy</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">&lt;no title&gt;</a></li>
      <li>Next: <a href="api.html" title="next chapter">API</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Petter Nilsson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>