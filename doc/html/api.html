<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API &mdash; mode-count 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="mode-count 0.1 documentation" href="index.html" />
    <link rel="prev" title="Documentation" href="documentation.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="modecount.Abstraction">
<em class="property">class </em><code class="descclassname">modecount.</code><code class="descname">Abstraction</code><span class="sig-paren">(</span><em>lower_bounds</em>, <em>upper_bounds</em>, <em>eta</em>, <em>tau</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.Abstraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Discrete abstraction of the hyper box defined by <em>lower_bounds</em> and <em>upper_bounds</em>.
Time discretization is <em>tau</em> and space discretization is given by <em>eta</em>.
Mode transitions are added with <a class="reference internal" href="#modecount.Abstraction.add_mode" title="modecount.Abstraction.add_mode"><code class="xref py py-func docutils literal"><span class="pre">add_mode()</span></code></a>.</p>
<dl class="method">
<dt id="modecount.Abstraction.add_mode">
<code class="descname">add_mode</code><span class="sig-paren">(</span><em>vf</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.Abstraction.add_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new dynamic mode to the abstraction, given by the vector field <em>vf</em>.</p>
</dd></dl>

<dl class="method">
<dt id="modecount.Abstraction.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.Abstraction.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">True</span></code> if <em>point</em> is within the abstraction domain, <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="modecount.Abstraction.idx_to_node">
<code class="descname">idx_to_node</code><span class="sig-paren">(</span><em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.Abstraction.idx_to_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of <a class="reference internal" href="#modecount.Abstraction.node_to_idx" title="modecount.Abstraction.node_to_idx"><code class="xref py py-func docutils literal"><span class="pre">node_to_idx()</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="modecount.Abstraction.node_to_idx">
<code class="descname">node_to_idx</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.Abstraction.node_to_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a node at discrete multiindex <span class="math">\((x,y,z)\)</span>, return the 
index <span class="math">\(L_z ( L_y x + y ) + z\)</span>, 
where <span class="math">\(L_z, L_y\)</span> are the (discrete) lengths of the hyper box domain,
and correspondingly for higher/lower dimensions. The function is a 1-1 mapping between
the nodes in the abstraction and the positive integers, and thus suitable as 
order_function in <a class="reference internal" href="#modecount.prefix_suffix_feasible" title="modecount.prefix_suffix_feasible"><code class="xref py py-func docutils literal"><span class="pre">prefix_suffix_feasible()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="modecount.Abstraction.plot_planar">
<code class="descname">plot_planar</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#modecount.Abstraction.plot_planar" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a 2D abstraction.</p>
</dd></dl>

<dl class="method">
<dt id="modecount.Abstraction.point_to_midx">
<code class="descname">point_to_midx</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.Abstraction.point_to_midx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the node multiindex corresponding to the continuous point <em>point</em>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="modecount.CycleControl">
<em class="property">class </em><code class="descclassname">modecount.</code><code class="descname">CycleControl</code><span class="sig-paren">(</span><em>G</em>, <em>sol</em>, <em>order_fcn</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.CycleControl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="synthesis-functions">
<h2>Synthesis functions<a class="headerlink" href="#synthesis-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="modecount.lin_syst">
<code class="descclassname">modecount.</code><code class="descname">lin_syst</code><span class="sig-paren">(</span><em>G</em>, <em>order_fcn=None</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.lin_syst" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a graph <em>G</em> with edges labeled with integers <span class="math">\(1, ..., M\)</span>, compute
matrices <span class="math">\(A,B\)</span> such that</p>
<div class="math">
\[\mathbf w(t+1) = A \mathbf w + B \mathbf r,\]</div>
<p>where <span class="math">\(w_i\)</span> represents the number of individual systems at node <span class="math">\(n\)</span> in mode <span class="math">\(m\)</span> if</p>
<div class="math">
\[i = (m-1) K + order\_fcn(n).\]</div>
<p>If no order function is specified, ordering by <strong>G.nodes().index</strong> is used.</p>
</dd></dl>

<dl class="function">
<dt id="modecount.prefix_suffix_feasible">
<code class="descclassname">modecount.</code><code class="descname">prefix_suffix_feasible</code><span class="sig-paren">(</span><em>problem_data</em>, <em>verbosity=1</em>, <em>solver=None</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.prefix_suffix_feasible" title="Permalink to this definition">¶</a></dt>
<dd><p>Define and solve a mode-counting synthesis problem
with a prefix-suffix strategy.</p>
<p>Inputs:</p>
<ul>
<li><p class="first"><em>problem_data</em>: dictionary with the following fields:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'graph'</span></code>                     : mode-transition graph G</li>
<li><code class="docutils literal"><span class="pre">'init'</span></code>                      : initial configuration in G</li>
<li><code class="docutils literal"><span class="pre">'horizon'</span></code>       : length of strategy prefix part</li>
<li><code class="docutils literal"><span class="pre">'cycle_set'</span></code>     : set of cycles from which suffix part is formed</li>
<li><code class="docutils literal"><span class="pre">'mode'</span></code>          : mode to count</li>
<li><code class="docutils literal"><span class="pre">'lb_suffix'</span></code>     : lower mode-counting bound in suffix phase</li>
<li><code class="docutils literal"><span class="pre">'ub_suffix'</span></code>     : upper mode-counting bound in suffix phase</li>
</ul>
<p>Optional fields</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'lb_prefix'</span></code>       : lower mode-counting bound in prefix phase (default: lb_suffix)</li>
<li><code class="docutils literal"><span class="pre">'ub_prefix'</span></code>       : upper mode-counting bound in prefix phase (default: ub_suffix)</li>
<li><code class="docutils literal"><span class="pre">'order_function'</span></code>  : a function that is a bijection that maps nodes in G to integers <span class="math">\([0, 1, \ldots , N]\)</span>  (default: G.nodes().index)</li>
<li><code class="docutils literal"><span class="pre">'forbidden_nodes'</span></code> : nodes in G that can not be visited (default: [])</li>
<li><code class="docutils literal"><span class="pre">'ilp'</span></code>             : if true, solve as ILP (default: <code class="docutils literal"><span class="pre">True</span></code>)</li>
</ul>
</li>
<li><p class="first"><em>verbosity</em>: level of verbosity</p>
</li>
</ul>
<p>Output: a dictionary with the following fields:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'controls'</span></code>        : prefix part u of strategy, u[:,t] is control at time t</li>
<li><code class="docutils literal"><span class="pre">'states'</span></code>          : states x generated by u, x[:,t] is state at time t</li>
<li><code class="docutils literal"><span class="pre">'cycles'</span></code>          : suffix cycles</li>
<li><code class="docutils literal"><span class="pre">'assignments'</span></code>     : suffix assignments</li>
</ul>
<p>Example: see example_simple.py</p>
</dd></dl>

<dl class="function">
<dt id="modecount.prefix_feasible">
<code class="descclassname">modecount.</code><code class="descname">prefix_feasible</code><span class="sig-paren">(</span><em>problem_data</em>, <em>verbosity=1</em>, <em>solver=None</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.prefix_feasible" title="Permalink to this definition">¶</a></dt>
<dd><p>Define and solve the prefix part of a mode-counting 
synthesis problem (requires a given suffix part)</p>
<p>Inputs:</p>
<ul>
<li><p class="first"><em>problem_data</em>: dictionary with the following fields:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'graph'</span></code>                     : mode-transition graph G</li>
<li><code class="docutils literal"><span class="pre">'init'</span></code>                      : initial configuration in G</li>
<li><code class="docutils literal"><span class="pre">'horizon'</span></code>           : length of strategy prefix part</li>
<li><code class="docutils literal"><span class="pre">'cycle_set'</span></code>     : cycles to form suffix part</li>
<li><code class="docutils literal"><span class="pre">'assignments'</span></code>   : assignments to <code class="docutils literal"><span class="pre">'cycle_set'</span></code></li>
<li><code class="docutils literal"><span class="pre">'mode'</span></code>          : mode to count</li>
<li><code class="docutils literal"><span class="pre">'lb_prefix'</span></code>     : lower mode-counting bound in prefix phase</li>
<li><code class="docutils literal"><span class="pre">'ub_prefix'</span></code>     : upper mode-counting bound in prefix phase</li>
</ul>
<p>Optional fields</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'order_function'</span></code> : a function that is a bijection that maps nodes in G to integers <span class="math">\([0, 1, \ldots , N]\)</span>  (default: G.nodes().index)</li>
<li><code class="docutils literal"><span class="pre">'forbidden_nodes'</span></code>: nodes in G that can not be visited (default: [])</li>
<li><code class="docutils literal"><span class="pre">'ilp'</span></code>            : if true, solve as ILP (default: <code class="docutils literal"><span class="pre">True</span></code>)</li>
</ul>
</li>
<li><p class="first"><em>verbosity</em>: level of verbosity</p>
</li>
</ul>
<p>Output: a dictionary with the following fields:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'controls'</span></code>       : prefix part u of strategy, u[:,t] is control at time t</li>
<li><code class="docutils literal"><span class="pre">'states'</span></code>         : states x generated by u, x[:,t] is state at time t</li>
<li><code class="docutils literal"><span class="pre">'cycles'</span></code>         : suffix cycles (same as input)</li>
<li><code class="docutils literal"><span class="pre">'assignments'</span></code>    : suffix assignments (same as input)</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="modecount.make_integer">
<code class="descclassname">modecount.</code><code class="descname">make_integer</code><span class="sig-paren">(</span><em>assignments</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.make_integer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Round assignments in &#8216;assignments&#8217; using cascade rounding s.t.</dt>
<dd><ul class="first last simple">
<li>sum of all assignments is preserved</li>
<li>every assignment is integral</li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="handle-solutions">
<h2>Handle solutions<a class="headerlink" href="#handle-solutions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="modecount.cyclequot">
<code class="descclassname">modecount.</code><code class="descname">cyclequot</code><span class="sig-paren">(</span><em>G</em>, <em>cycle</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.cyclequot" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given &#8216;cycle&#8217;, compute the proportion of nodes that are in &#8216;mode&#8217;</p>
</dd></dl>

<dl class="function">
<dt id="modecount.cycle_maxmin">
<code class="descclassname">modecount.</code><code class="descname">cycle_maxmin</code><span class="sig-paren">(</span><em>G</em>, <em>cycle</em>, <em>mode</em>, <em>assignment</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.cycle_maxmin" title="Permalink to this definition">¶</a></dt>
<dd><p>For a given &#8216;cycle&#8217; and &#8216;assignment&#8217;, compute mode-counting bounds for &#8216;mode&#8217;</p>
</dd></dl>

<dl class="function">
<dt id="modecount.suffix_maxmin">
<code class="descclassname">modecount.</code><code class="descname">suffix_maxmin</code><span class="sig-paren">(</span><em>G</em>, <em>cycles</em>, <em>mode</em>, <em>assignments</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.suffix_maxmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a suffix strategy consisting of <cite>cycles</cite> and <cite>assignments</cite>, compute upper and lower mode-counting bounds
for the mode <cite>mode</cite>.</p>
</dd></dl>

<dl class="function">
<dt id="modecount.prefix_maxmin">
<code class="descclassname">modecount.</code><code class="descname">prefix_maxmin</code><span class="sig-paren">(</span><em>G</em>, <em>states</em>, <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#modecount.prefix_maxmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of &#8216;states&#8217;, compute upper and lower mode-counting bounds
for the mode <cite>mode</cite>.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API</a><ul>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#synthesis-functions">Synthesis functions</a></li>
<li><a class="reference internal" href="#handle-solutions">Handle solutions</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="documentation.html" title="previous chapter">Documentation</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Petter Nilsson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>